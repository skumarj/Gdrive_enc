<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Password-Protected Drive Encryption</title>

  <!-- Google Identity Services (token client) -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <!-- gapi client (optional, for discovery) -->
  <script src="https://apis.google.com/js/api.js" async defer></script>

  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; max-width:900px; margin:2rem; }
    label, input, button { display:block; margin: .5rem 0; }
    #files { margin-top:1rem; }
    pre { background:#f6f8fa;padding:1rem;border-radius:6px;overflow:auto; }
  </style>
</head>
<body>
  <h1>Password-Protected Drive Encryption (Client-side)</h1>

  <p>Replace CLIENT_ID and API_KEY with values from your Google Cloud Console. Use the Drive API and configure OAuth consent.</p>

  <label>
    File
    <input type="file" id="file">
  </label>

  <label>
    Password
    <input type="password" id="password" placeholder="Password">
  </label>

  <div>
    <button id="btnEncryptUpload">Encrypt & Upload</button>
    <button id="btnList">List .enc Files</button>
  </div>

  <div id="status" aria-live="polite"></div>
  <div id="files"></div>

<script>
/* ================= CONFIG ================= */
/* TODO: Replace with your project's credentials */
const CLIENT_ID = "723767973939-c632uu108p8sclccv6qkoe77ehdm0kpb.apps.googleusercontent.com";
const API_KEY   = "AIzaSyC7einH7PwYT3xYLzpnnR-MQjNkI8YW-gU";
const SCOPES    = "https://www.googleapis.com/auth/drive.file"; // least privilege for files your app creates

/* ================= UTILITIES ================= */
function log(msg) { document.getElementById('status').textContent = msg; }

function arrayBufferToBase64(ab) {
  const bytes = new Uint8Array(ab);
  let binary = '';
  const chunk = 0x8000;
  for (let i = 0; i < bytes.length; i += chunk) {
    const sub = bytes.subarray(i, i + chunk);
    binary += String.fromCharCode.apply(null, sub);
  }
  return btoa(binary);
}

function base64ToArrayBuffer(b64) {
  const binary = atob(b64);
  const len = binary.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
  return bytes.buffer;
}

/* ================= AUTH: Google Identity Services token client ================= */
let tokenClient;
let accessToken = null;

function ensureTokenClient() {
  if (tokenClient) return tokenClient;
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: CLIENT_ID,
    scope: SCOPES,
    callback: (resp) => {
      // This callback will be overwritten in requestAccessToken Promise wrapper
    }
  });
  return tokenClient;
}

function requestAccessToken(promptIfNeeded = false) {
  return new Promise((resolve, reject) => {
    ensureTokenClient();
    tokenClient.callback = (resp) => {
      if (resp.error) return reject(new Error(resp.error));
      accessToken = resp.access_token;
      resolve(accessToken);
    };
    try {
      tokenClient.requestAccessToken({ prompt: promptIfNeeded ? 'consent' : '' });
    } catch (err) {
      reject(err);
    }
  });
}

/* Optional: initialize gapi.client discovery (not required for fetch-based calls) */
async function initGapiClient() {
  return new Promise((resolve) => {
    gapi.load('client', async () => {
      try {
        await gapi.client.init({ apiKey: API_KEY, discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'] });
      } catch (e) {
        console.warn('gapi.client.init failed (non-fatal):', e);
      }
      resolve();
    });
  });
}

/* ================= CRYPTO PRIMITIVES ================= */

/*
  Design:
  - Generate a random FEK (File Encryption Key, AES-GCM)
  - Derive KEK (Key Encryption Key) from password with PBKDF2(salt, iterations)
  - Encrypt file with FEK (AES-GCM, 12-byte IV)
  - Export FEK (raw) and encrypt it with KEK (AES-GCM, 12-byte IV)
  - Store encrypted FEK, salt, and IVs in file.appProperties (base64 strings)
*/

async function deriveKEK(password, salt, iterations = 200000) {
  const enc = new TextEncoder();
  const baseKey = await crypto.subtle.importKey('raw', enc.encode(password), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations, hash: 'SHA-256' },
    baseKey,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
}

async function generateFEK() {
  // we need to export FEK so make it extractable
  return crypto.subtle.generateKey({ name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']);
}

async function encryptWithKey(key, dataBuffer) {
  const iv = crypto.getRandomValues(new Uint8Array(12)); // 96-bit recommended
  const cipher = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, dataBuffer);
  return { cipher, iv };
}

async function decryptWithKey(key, cipherBuffer, iv) {
  return crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, cipherBuffer);
}

/* ================= DRIVE UPLOAD / LIST / DOWNLOAD ================= */

async function uploadMultipart(encryptedFileBuffer, filename, metadata) {
  const boundary = '-----------' + Date.now();
  const delimiter = `\r\n--${boundary}\r\n`;
  const closeDelim = `\r\n--${boundary}--`;

  const jsonPart = `Content-Type: application/json; charset=UTF-8\r\n\r\n${JSON.stringify(metadata)}`;

  const bodyParts = [];
  bodyParts.push(delimiter);
  bodyParts.push(jsonPart);
  bodyParts.push(delimiter);
  bodyParts.push('Content-Type: application/octet-stream\r\n\r\n');
  bodyParts.push(new Blob([encryptedFileBuffer]));
  bodyParts.push(closeDelim);

  const body = new Blob(bodyParts);

  const token = await requestAccessToken();
  const res = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name', {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${token}`,
      'Content-Type': `multipart/related; boundary=${boundary}`
    },
    body
  });

  if (!res.ok) {
    const txt = await res.text();
    throw new Error(`Upload failed: ${res.status} ${res.statusText}\n${txt}`);
  }

  return res.json();
}

async function listEncryptedFiles() {
  const token = await requestAccessToken();
  // Convention: files created by this UI have ".enc" in name and contain appProperties we set
  const q = "name contains '.enc' and trashed = false";
  const params = new URLSearchParams({ pageSize: '100', fields: 'files(id,name,appProperties)', q });
  const res = await fetch(`https://www.googleapis.com/drive/v3/files?${params}`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  if (!res.ok) throw new Error('List failed: ' + res.statusText);
  return res.json();
}

async function downloadFileContent(fileId) {
  const token = await requestAccessToken();
  const res = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  if (!res.ok) {
    const txt = await res.text();
    throw new Error(`Download failed: ${res.status} ${res.statusText}\n${txt}`);
  }
  return res.arrayBuffer();
}

/* ================= UI ACTIONS ================= */

document.getElementById('btnEncryptUpload').addEventListener('click', async () => {
  try {
    log('Initializing...');
    await initGapiClient(); // optional
    const fileInput = document.getElementById('file');
    const pw = document.getElementById('password').value || '';

    if (!fileInput.files.length) { alert('Select a file'); return; }
    if (!pw) { alert('Enter a password'); return; }

    const file = fileInput.files[0];
    log(`Reading "${file.name}"...`);
    const fileBuffer = await file.arrayBuffer();

    // 1) Generate FEK and derive KEK from password
    log('Generating FEK & deriving KEK...');
    const fek = await generateFEK();
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const kek = await deriveKEK(pw, salt, 200000);

    // 2) Encrypt file with FEK
    log('Encrypting file with FEK...');
    const { cipher: encryptedFileBuffer, iv: fileIV } = await encryptWithKey(fek, fileBuffer);

    // 3) Export FEK and encrypt it with KEK
    log('Encrypting FEK with KEK...');
    const rawFek = await crypto.subtle.exportKey('raw', fek); // ArrayBuffer
    const { cipher: encFekBuffer, iv: keyIV } = await encryptWithKey(kek, rawFek);

    // 4) Upload multipart: encrypted file body + metadata (appProperties)
    log('Uploading encrypted file to Drive (you may be prompted)...');

    const meta = {
      // metadata visible to your app only via appProperties
      appProperties: {
        originalName: file.name,
        salt: arrayBufferToBase64(salt.buffer),
        fileIV: arrayBufferToBase64(fileIV.buffer),
        keyIV: arrayBufferToBase64(keyIV.buffer),
        encFEK: arrayBufferToBase64(encFekBuffer)
      }
    };

    const res = await uploadMultipart(encryptedFileBuffer, file.name + '.enc', meta);
    log(`Upload complete: ${res.name} (id: ${res.id})`);
    alert('Encrypted file uploaded to Drive.');
  } catch (err) {
    console.error(err);
    alert('Error: ' + (err.message || err));
    log('Error: ' + (err.message || err));
  }
});

document.getElementById('btnList').addEventListener('click', async () => {
  try {
    log('Listing .enc files...');
    const resp = await listEncryptedFiles();
    const files = resp.files || [];

    const container = document.getElementById('files');
    container.innerHTML = '';
    if (files.length === 0) {
      container.textContent = 'No .enc files found.';
      log('No files found.');
      return;
    }

    const ul = document.createElement('ul');
    for (const f of files) {
      const li = document.createElement('li');
      const title = document.createElement('span');
      title.textContent = `${f.name} `;
      li.appendChild(title);

      const btn = document.createElement('button');
      btn.textContent = 'Download & Decrypt';
      btn.addEventListener('click', async () => {
        try {
          const pw = prompt('Enter password to decrypt ' + (f.appProperties?.originalName || f.name));
          if (!pw) return;

          log('Downloading encrypted file...');
          const encryptedArrayBuffer = await downloadFileContent(f.id);

          const ap = f.appProperties || {};
          if (!ap.encFEK || !ap.salt || !ap.keyIV || !ap.fileIV) throw new Error('Missing encryption metadata on file');

          // Recover components
          const encFekBuf = base64ToArrayBuffer(ap.encFEK);
          const saltBuf = base64ToArrayBuffer(ap.salt);
          const keyIV = new Uint8Array(base64ToArrayBuffer(ap.keyIV));
          const fileIV = new Uint8Array(base64ToArrayBuffer(ap.fileIV));

          log('Deriving KEK from password...');
          const kek = await deriveKEK(pw, new Uint8Array(saltBuf), 200000);

          log('Decrypting FEK...');
          const rawFekBuf = await decryptWithKey(kek, encFekBuf, keyIV); // ArrayBuffer

          // Import FEK and use it to decrypt file
          const fek = await crypto.subtle.importKey('raw', rawFekBuf, { name: 'AES-GCM' }, false, ['decrypt']);
          log('Decrypting file with FEK...');
          const decryptedBuffer = await decryptWithKey(fek, encryptedArrayBuffer, fileIV);

          // Offer file for download
          const blob = new Blob([decryptedBuffer], { type: 'application/octet-stream' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = ap.originalName || f.name.replace(/\.enc$/, '');
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          log('Decryption & download complete.');
        } catch (err) {
          console.error(err);
          alert('Error decrypting file: ' + (err.message || err));
          log('Error: ' + (err.message || err));
        }
      });

      li.appendChild(btn);
      ul.appendChild(li);
    }
    container.appendChild(ul);
    log(`Found ${files.length} .enc file(s).`);
  } catch (err) {
    console.error(err);
    alert('List error: ' + (err.message || err));
    log('Error: ' + (err.message || err));
  }
});

/* ================= NOTES / SECURITY =================

- This is client-side end-to-end encryption:
  - The plaintext never leaves the browser.
  - Only the encrypted payload and encrypted FEK are stored in Drive.

- appProperties is used to store small metadata (base64-encoded). appProperties is readable only by the app that created the file.

- PBKDF2 iterations: 200k (tune for your environment). Higher iterations increase CPU cost for attackers but also for legitimate users/devices.

- AES-GCM nonces (IVs) are 12 bytes (recommended). Do not reuse IV for same key.

- For very large files (> ~5-10MB) consider Drive's resumable upload and stream encryption (chunked), rather than loading entire file into memory.

- This example uses the Google Identity Services token client (recommended). Replace CLIENT_ID/API_KEY and enable Drive API in Cloud Console.

- This implementation exports FEK so it can be wrapped with KEK. If you want a scheme where FEK is not extractable, you'd need a different wrapping approach (e.g., use a KMS or server-side wrapping).

=============================================== */
</script>
</body>
  </html>
